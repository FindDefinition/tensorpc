## Data Model component

In this tutorial, we will learn how to use data model based UI. 

### Problems

We often encounter following two problems during development:

* Share same variable across multiple components

When we have multiple components that share the same variable, we need to pass the variable to each component and send event to frontend. This is not only cumbersome, but also error-prone.

* Render large list/table 

Currently we need to create a huge list of UIs for each data item, which is hard to maintain and slow to render.


### `mui.DataModel` and `bind_fields`

#### Overview

`mui.DataModel` is a data model component container, it wraps a `dataclasses` object. To let child components access value of your `dataclasses`, use `bind_fields` to bind a value to a child component.

```Python

from tensorpc.flow import mui, marker
import dataclasses

@dataclasses.dataclass
class Model:
    name: str 
    count: int 

class App:
    @marker.mark_create_layout
    def layout(self):
        model = Model("test", 1)
        # this draft is only used for binding fields, don't use it to update values
        model_draft = mui.DataModel.get_draft_external(model)
        self.dm = mui.DataModel(Model("test", 1), [
            mui.Markdown().bind_fields(value=model_draft.name),
            mui.Markdown().bind_fields(value=f"to_string({model_draft.count})"),
            mui.Button("increment", self._handle_button),
            mui.Button("increment With Draft Update", self._handle_button_draft),
        ])
        return mui.VBox([
            self.dm
        ])

    async def _handle_button(self):
        self.dm.model.count += 1
        # explicitly sync whole model to update UI, slow for large model.
        await self.dm.sync_model()

    async def _handle_button_draft(self):
        # use draft to update data, inspired by `immer`.
        # you can't update data directly with plain dataclasses object, you must
        # use draft.
        draft = self.dm.get_draft()
        draft.count += 1
```

#### JMESPath

We use [jmespath](https://jmespath.org/) as data query language for `bind_fields`, you can use `jmespath` expression to query data from `mui.DataModel`.

**WARNING**: if jmespath expression is invalid, it will return `undefined` instead of `null`, also all jmespath query results will be convert to `undefined` even if it's a `null` (None) set by user because almost all component props accept `undefined` instead of `null`.

#### Draft and JMESPath

We can see we use draft object instead of string as `jmespath`, this is a grammar sugar to make attribute error check works with modern ide. when you create a draft and access fields, a jmespath expression is generated automatically.

#### Update UI by change Model

since all child components are binded to model, you can update these binded fields to directly update all related components.

`_handle_button` method sync whole model to frontend, so related `Markdown` components will be updated.

Update whole model is simple, but slow for large model. 

#### Update UI by draft

We recommend to use `draft` to update model, it's inspired by `immer`. all changes you made to draft will be recorded and applied in frontend via a `JSONPath` like way, so it's very fast and simple. To make life easier, we record all draft operation inside any event handler, you don't need to call any async function to send events to frontend.

To use draft update, you need to get draft object from `mui.DataModel`.

Keep in mind that draft operations is recorded and sent **AFTER** event handler run. If you want to send event immediately, you can use `draft_update`:

```
async with self.dm.draft_update() as draft:
    draft.count += 1
```

Events will be sent immediately after `async with` block.

### Optional UI

Recall the jmespath invalid behavior, all binded fields will become `undefined`. We won't unmount components if their binded prop query result is `undefined`. To make components invisible instead of render with `undefined` props, we can use `mui.MatchCase`.

```Python

from tensorpc.flow import mui, marker
import dataclasses
from typing import Optional

@dataclasses.dataclass
class ModelItem:
    name: str 

@dataclasses.dataclass
class Model:
    item: Optional[ModelItem]

class App:
    @marker.mark_create_layout
    def layout(self):
        model = Model(ModelItem("## test"))
        # this draft is only used for binding fields, don't use it to update values
        model_draft = mui.DataModel.get_draft_external(model)
        self.dm = mui.DataModel(model, [
            mui.Switch("Show", self._handle_sw, init_value=True),
            mui.MatchCase([
                mui.MatchCase.Case(True, mui.Markdown().bind_fields(value="item.name")),
                mui.MatchCase.Case(False, mui.Markdown("## Hidden")),
            ]).bind_fields(condition=f"{model_draft.item} != null"),
        ])
        return mui.VBox([
            self.dm
        ])

    async def _handle_sw(self, enable):
        draft = self.dm.get_draft()
        draft.item = None if not enable else ModelItem("## test")
```


### Nested Data Model

Currently nested data model has limited support. All components can only see closest parent model, so you can't access grandparent model directly. We will improve this in future.